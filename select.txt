#pragma comment (lib,"ws2_32.lib")
#include <WS2tcpip.h>
#include <iostream>

using std::cout;
using std::endl;

void err_display(const char*);
void PrintIP(LPVOID);
void EchoServ(SOCKET, fd_set*);
int main()
{
	//1. dll 활성화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa)) //if(WST() != 0)
	{
		err_display("WSAStartup");
		return -1;
	}

	//2. tcp 소켓 생성 : 문지기 소켓
	SOCKET s_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s_sock == INVALID_SOCKET)
	{
		err_display("socket");
		return -1;
	}

	//2. 소켓과 사용할 정보(IP주소 + 포트번호)를 묶는다(시스템에 예약한다) 
	//2.1 사용할 IP주소 및 port 번호를 저장할 메모리를 생성
	SOCKADDR_IN saddr;
	saddr.sin_family = AF_INET; //(host byte order)
	saddr.sin_port = htons(8000); //network byte order
	saddr.sin_addr.s_addr = htons(INADDR_ANY); //network byte order

	if (bind(s_sock, (SOCKADDR*)&saddr, sizeof(saddr)) == SOCKET_ERROR)
	{
		err_display("bind");
		return -1;
	}
	//select를 위한 집합 처리
	fd_set readfds, copyfds;	//집합 생성  fd_count=0, fd_array
	FD_ZERO(&readfds);			//집합 초기화
	FD_ZERO(&copyfds);
	FD_SET(s_sock, &readfds);   //readfds 집합에 s_sock를 insert
	                            //readfds.fd_count -> 1
								//readfds.fd_array[0] -> s_sock


	//4. 연결(three-way-handshake protocol)에 사용할 queue를 생성
	if (listen(s_sock, SOMAXCONN) == SOCKET_ERROR)
	{
		err_display("listen");
		return -1;
	}

	SOCKADDR_IN caddr;
	int namelen = sizeof(caddr);
	int retval;
	while(true){
		copyfds = readfds; //select 리턴 후, readfds 부분의 값이 변하기 때문
		retval = select(0, &copyfds, NULL, NULL, NULL);
		if (retval == 0 || retval == SOCKET_ERROR)
		{
			err_display("select");
			break;
		}

		for (int i = 0; i < retval; i++)
		{
			if (FD_ISSET(s_sock, &copyfds))
			{
				SOCKET newsock = accept(s_sock, (SOCKADDR*)&caddr, &namelen);
				if (newsock == INVALID_SOCKET)
				{
					cout << "accept error" << endl;
					return -1;
				}
				//readfds <- newsock insert
				FD_SET(newsock, &readfds);
				continue;
			}
			EchoServ(copyfds.fd_array[i], &readfds);
		}	
	}

	closesocket(s_sock);
	WSACleanup();
	return 0;
}

void EchoServ(SOCKET s, fd_set* set)
{
	const int MAXBUF = 80;
	char buf[MAXBUF];
	int recvlen;

	recvlen = recv(s, buf, MAXBUF - 1, 0);
	if (recvlen == SOCKET_ERROR)
	{
		cout << "reset connection case" << endl;
		closesocket(s);
		//readfds -> s  delete
		FD_CLR(s, set);
		return;
	}
	if (recvlen == 0)
	{
		cout << "close connection case" << endl;
		closesocket(s);
		//readfds -> s  delete
		FD_CLR(s, set);
		return;
	}
	buf[recvlen] = '\0';
	cout << buf << endl;
	send(s, buf, recvlen, 0);
}


void PrintIP(LPVOID addr)
{
	char IPbuf[20];
	if (inet_ntop(AF_INET, addr, IPbuf, 20) == NULL)
	{
		err_display("inet_ntop error");
		return;
	}
	cout << "IP addr : " << IPbuf << endl;

}

void err_display(const char* mes)
{
	char* buf = NULL;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPSTR)&buf, 0, NULL);
	cout << mes << " : " << buf << endl;
	LocalFree(buf);
}